<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="google-site-verification" content="ZTGlAm3wCdTRlvNAYml9RoZNQbJMibkAuuxNIcVRjHY" />
    
<!-- Google Analytics -->
<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "G-6ZP9QPH0GE", "auto");
  ga("send", "pageview");
</script>
<!-- End Google Analytics -->

 
    <title>Madaolabs</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta property="og:type" content="website">
<meta property="og:title" content="Madaolabs">
<meta property="og:url" content="https://blog.madaotech.top/index.html">
<meta property="og:site_name" content="Madaolabs">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">  
    <link rel="icon" href="/favicon.ico" />
     
    <link
      href="//fonts.loli.net/css?family=Source+Code+Pro"
      rel="stylesheet"
      type="text/css"
    />
    
    <link
      href="https://fonts.loli.net/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean"
      rel="stylesheet"
    />
    
<link rel="stylesheet" href="/css/style.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
</html>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"> </a>
        <a href="/" id="main-nav-title" class="main-nav-link">
          Madaolabs</a
        >
        
        <a class="main-nav-link" href="/archives/"
          >Archives</a
        >
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-blockchain/consensus/POH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/26/blockchain/consensus/POH/">POH Consensus</a>
    </h1>
  

        <a href="/2024/02/26/blockchain/consensus/POH/" class="article-date">
  <time datetime="2024-02-26T14:03:55.000Z" itemprop="datePublished">2024-02-26</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Solana 链上的共识机制是 DPoS（委托权益证明） 和 PoH（历史证明），其中 PoH 是 Solana 高 TPS 的核心原因，理论峰值 TPS 为 65,000。下面我们详细说说 PoH 是如何做的。</p>
<h3 id="传统共识机制-Pow-和-PoS"><a href="#传统共识机制-Pow-和-PoS" class="headerlink" title="传统共识机制(Pow 和 PoS)"></a>传统共识机制(Pow 和 PoS)</h3><p>传统共识机制中的每一个节点都有自己的内部时钟，它按照本地系统时钟执行。当交易发生时，节点根据本地时钟为交易新增时间戳。所有的节点需要相互沟通，协调彼此的本地时钟，以确保他们处理交易时时间是一致的。当有成千上万个节点分布在全球各地，就会遇到<strong>时间戳同步问题</strong>，要同步时间就需要花费大量的时间和处理能力来验证时间戳的准确性。倒是区块确认的延迟，甚至拒绝。</p>
<h3 id="什么是-PoH（历史证明）"><a href="#什么是-PoH（历史证明）" class="headerlink" title="什么是 PoH（历史证明）"></a>什么是 PoH（历史证明）</h3><p>PoH 是选择一个节点（领导节点），以此节点的时间为全局时间，所有节点都使用它来验证两个事件的交易顺序。PoH 依赖于一种加密方法，以建立交易的连续，按时间顺序记录。</p>
<p>在 Solana 中每个交易都经过 SHA-256 处理，一个交易的 hash 是下一个交易 hash 的输入。这个过程建立一个长而连续的链。PoH 利用 VDF（可验证延迟函数）实现对交易的 hash 以及经过的时间，这是一个串行之行，提供了一个具有加密可靠的交易顺序。</p>
<h3 id="DPoS（委托权益证明）"><a href="#DPoS（委托权益证明）" class="headerlink" title="DPoS（委托权益证明）"></a>DPoS（委托权益证明）</h3><p>为了更好的了解 PoH，我们结合 DPoS 看看。<br>在 DPoS 中，每个抵押了 SOL 的验证者能够参与网络治理。对区块的有效性进行投票，决定是否将其新增到区块链中。不愿直接参与的权益证明的 SOL 持有者，可以将其委托给其他验证者。作为抵押 SOL 的回报，委托人将获得区块奖励的一部分。</p>
<p>DPoS 的运作原则是，具有较大权益的节点更有可能被选择来验证交易并将其新增到区块链中。</p>
<h3 id="Solana-共识机制的概述"><a href="#Solana-共识机制的概述" class="headerlink" title="Solana 共识机制的概述"></a>Solana 共识机制的概述</h3><ol>
<li>领导节点的选择： 领导节点负责生成 PoH 序列和建立区块</li>
<li>领导节点将接收交易，并使用 PoH 为它们新增时间戳，形成交易顺序。</li>
<li>建立区块</li>
<li>区块传播： 将新建立的区块发送给复制节点（其他验证者）。</li>
<li>负责节点验证：1. 使用 PoH 序列验证交易顺序，2. 验证交易规则是否有效</li>
<li>区块新增到区块链中。选择下一个领导节点，重新开始</li>
</ol>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2024/02/26/blockchain/consensus/POH/" data-id="cluyygvyc0010j9psgklw9rs7" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain/btc/address" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/12/14/blockchain/btc/address/">解读 BTC 的地址类型以及交易模型</a>
    </h1>
  

        <a href="/2023/12/14/blockchain/btc/address/" class="article-date">
  <time datetime="2023-12-14T16:42:09.000Z" itemprop="datePublished">2023-12-14</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>BTC 的交易是基于 UTXO 系统，本文不介绍 UTXO，不知道的同学自行查阅学习。</p>
<p><strong>比特币主网的地址类型分为 4 中:</strong></p>
<ol>
<li>1…（Pay-to-Public-Key-Hash（P2PKH）类型的脚本）</li>
<li>3…（Pay-to-Script-Hash (P2SH) 类型的脚本）</li>
<li>bc1q…（Segwit 隔离见证地址）</li>
<li>bc1p…（Taproot）</li>
</ol>
<p>每一类地址背后对应一种 BTC 的技术升级，下面逐个分析每一类地址用到的技术。</p>
<h4 id="以-1-开头的地址（P2PKH）"><a href="#以-1-开头的地址（P2PKH）" class="headerlink" title="以 1 开头的地址（P2PKH）"></a><strong>以 1 开头的地址（P2PKH）</strong></h4><p>这是 BTC 最原始的地址，此类地址功能非常纯粹，只能做转账。如交易<a target="_blank" rel="noopener" href="https://www.blockchain.com/explorer/transactions/btc/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2">062705…c2f2</a></p>
<p>下面是该交易的详细数据，通过这个交易我们需要学习到 2 个概念: <strong>解锁脚本和锁定脚本（scriptSig 和 scriptPubKey）</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locktime&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;vin&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;txid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;scriptSig&quot;</span><span class="punctuation">:</span> <span class="string">&quot;483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sequence&quot;</span><span class="punctuation">:</span> <span class="number">4294967295</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.015</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.0845</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>vin</strong> 交易输入标识哪个 UTXO（通过引用）将被消费，并通过解锁脚本（scriptSig）提供所有权证明。其中 txid 和 vout 表示用户上 1 笔收款交易，可以索引到一条 UTXO 列表中的数据。scriptSig 用于解锁 UTXO 中的数据。</p>
<p><strong>vout</strong> 表示这个交易的输出。</p>
<h4 id="以-3-开头的地址（P2SH）"><a href="#以-3-开头的地址（P2SH）" class="headerlink" title="以 3 开头的地址（P2SH）"></a><strong>以 3 开头的地址（P2SH）</strong></h4><p>上面的信息中在 P2PKH 的交易的解锁脚本（scriptSig）是用来解锁上一笔交易的输出的锁定脚本（scriptPubKey）。也就是说上一笔交易的锁定脚本（scriptPubKey）中的逻辑影响了本次交易的解锁脚本（scriptSig）。比如本次交易是多签转账，那么要求上一次交易的输出就要是多签的逻辑。</p>
<p>假设迪拜的电子产品进口商 Mohammed 对所有客户付款（会计术语称为“应收账款”）都使用多重签名脚本。基于多重签名方案，客户支付的任何款项都会被锁定，必须至少 2 个签名才能解锁，一个来自 Mohammed，另一个来自其合伙人或拥有备份密钥的律师。这样的多重签名机制能提升公司治理管控，同时也能有效防范盗窃、挪用和丢失。</p>
<p>那么 <strong>Mohammed 必须在客户付款前将上面的脚本发送给每一位客户，而每一位客户也必须使用专用的能创建自定义交易脚本的比特币钱包软件，每位客户还得学会如何利用自定义脚本来创建交易。</strong> 此外，由于脚本可能包含特别长的公钥，最终的交易脚本可能是最初交易脚本长度的 5 倍之多。超大的交易还将给客户造成费用负担。</p>
<p>P2SH 正是为了解决这一实际难题而被引入的，它使复杂脚本的使用能与直接向比特币地址支付一样简单。</p>
<p>具体实现如下：</p>
<ol>
<li>把复杂锁定脚本(这里给它一个新的名字叫: redeem script)通过两次哈希（sha256 和 ripemd160）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo \</span><br><span class="line">2 \</span><br><span class="line">[04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C587] \</span><br><span class="line">[04A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49] \</span><br><span class="line">[047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D9977965] \</span><br><span class="line">[0421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5] \</span><br><span class="line">[043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800] \</span><br><span class="line">5 CHECKMULTISIG \</span><br><span class="line">| bx script-encode | bx sha256 | bx ripemd160</span><br><span class="line">54c557e07dde5bb6cb791c7a540e0a4796f5e97e</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把上一步的计算结果进行 Base58Check 编码，由于 P2SH 地址采用 5 作为版本前缀，所以得到以 “3” 开头的地址, 告诉用户往这个地址转账。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo \</span><br><span class="line">&#x27;54c557e07dde5bb6cb791c7a540e0a4796f5e97e&#x27;\</span><br><span class="line"> | bx address-encode -v 5</span><br><span class="line">39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最终锁定脚本（scriptPubKey）变成</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对应的解锁脚本也是需要修改的，改为</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sig1&gt; &lt;Sig2&gt; &lt; redeem script &gt;</span><br></pre></td></tr></table></figure>

<p>我们再来看看是否可以解决 P2PKH 的问题，上一笔交易的输出只需要知道用户的地址就好了，并不需要知道其他，同时上一笔交易的锁定脚本的大小也得到了减少，费用转移到本次交易。P2SH 很好的解决 P2PKH 带来的问题。</p>
<h4 id="bc1q（Segwit-隔离见证地址）"><a href="#bc1q（Segwit-隔离见证地址）" class="headerlink" title="bc1q（Segwit 隔离见证地址）"></a><strong>bc1q（Segwit 隔离见证地址）</strong></h4><p>正式交易如： <a target="_blank" rel="noopener" href="https://www.blockchain.com/explorer/transactions/btc/ec9f03d79de1b408a2880e77b7be67c149ddb5e89c5b8c5a648fe29f4524d959">ec9f…d959</a><br>无论是 P2PKH，还是 P2SH，都会把脚本写在交易中，<strong>Segwit</strong> 把 <strong>解锁脚本</strong> 从交易中剔除，那么区块中可以容纳更多的交易。“见证”是密码学中的名词，含义是解锁方案，在我们这里叫做解锁脚本。这部分数据占据原交易的约 75%。矿工在验证输入后可以删除 witness</p>
<p>在 Segwit 升级后，P2PKH 和 P2SH 变为了 P2WPKH 和 P2WSH。在收款方的地址是 bc1q 的情况下。</p>
<p>P2WPKH 的具体的技术实现：</p>
<ol>
<li>上一笔交易的输出变为：见证版本号为 0 + 公钥哈希值(或者 reedom script 的 hash)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// P2PKH 的样子</span><br><span class="line">OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">// P2WPKH</span><br><span class="line">0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>本次交易的输入不再用 scriptSig</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// P2PKH</span><br><span class="line">&quot;vin&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;,</span><br><span class="line">      &quot;vout&quot;: 0,</span><br><span class="line">      &quot;scriptSig&quot;: &quot;483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;,</span><br><span class="line">      &quot;sequence&quot;: 4294967295</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">// P2WPKH</span><br><span class="line">&quot;vin&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;txid&quot;: &quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;,</span><br><span class="line">      &quot;vout&quot;: 0,</span><br><span class="line">      &quot;scriptSig&quot;: &quot;&quot;,</span><br><span class="line">      &quot;sequence&quot;: 4294967295,</span><br><span class="line">      &quot;witness&quot;: &quot;&lt;Bob&#x27; Signature&gt; &lt;Bob&#x27;s PublicKey&gt;&quot; 或者 &quot;&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>

<h4 id="bc1p…（Taproot-地址）"><a href="#bc1p…（Taproot-地址）" class="headerlink" title="bc1p…（Taproot 地址）"></a><strong>bc1p…（Taproot 地址）</strong></h4><p>真实交易: <a target="_blank" rel="noopener" href="https://www.blockchain.com/explorer/transactions/btc/3ef659aff282acc1f677b7c003a6edd07b810d85eaf3cb81210bd11ea3142e29">3ef65…2e29</a><br>Taproot 在 Segwit 的基础上进一步减小了存储空间，提高了交易效率，并提供了更好的隐私性, Taproot 升级包含 3 个升级:</p>
<ol>
<li>默克尔抽象语法树(MASK)</li>
<li>Schnorr 签名</li>
<li>Taproot（MASK 和 Schnorr 签名落地应用）</li>
</ol>
<h5 id="默克尔根和哈希树是如何生成的？"><a href="#默克尔根和哈希树是如何生成的？" class="headerlink" title="默克尔根和哈希树是如何生成的？"></a>默克尔根和哈希树是如何生成的？</h5><p>首先分别对所有脚本（条件）做哈希计算；然后将计算得到的哈希值与相邻哈希值组合起来进行哈希计算，生成一组新的哈希值。不断重复这个两两哈希计算的过程，直到计算出最后一个哈希值为止。这个哈希值就是默克尔根。</p>
<p>假设共有四组条件。首先，分别计算出这四组条件的哈希值；再将这四个哈希值两两配对，计算出两个哈希值；最后，把这两个哈希值组合起来做哈希计算，生成最终的哈希值。最后这个哈希值就是默克尔根。</p>
<p><img src="/2023/12/14/blockchain/btc/address/mask.webp"></p>
<p><strong>这个默克尔根可以翻译成一个能够接收付款的有效比特币地址</strong>，即，默克尔比特币地址（Merklized Bitcoin address）。默克尔比特币地址有很多优点，最主要的优点是无需知晓所有脚本单元就能验证某个脚本是否位于这棵默克尔树上。这个技术叫作默克尔证明（Merkle Proof），可以用来轻松验证一个比特币 UTXO 是否包含某些解锁条件。</p>
<p>在 MAST 中，BTC 与一棵默克尔树绑定。这棵默克尔树指定了可以解锁未花费 BTC 的所有复杂条件。每个叶节点都代表着一个条件。为了解锁 BTC，你必须生成一个满足默克尔树上某个分支所代表的条件的脚本。仅使用默克尔根即可验证这个条件是否属于原始条件集合（即验证某个叶节点是否在这棵默克尔树上）。一旦比特币区块链网络发现某个脚本（及其所代表的条件）属于这个默克尔根，网络就会知道这个脚本是这些比特币的锁定条件并开始验证解锁脚本。因此，我们无需生成完整的脚本并将其包含到交易内，即可花费以 MAST 锁定的 BTC。这有助于减少 BTC 交易的体积。</p>
<h5 id="Schnorr-签名"><a href="#Schnorr-签名" class="headerlink" title="Schnorr 签名"></a>Schnorr 签名</h5><p>在密码学中，Schnorr 签名是由 Claus Schnorr 提出的 Schnorr 签名算法生成的数字签名。 Schnorr 签名算法是一种以简单闻名的数字签名方案，通过将多个签名聚合成单个签名以优化验证和认证过程。该方案适用于多签交易。</p>
<p>若想执行交易，你需要使用私钥签名该交易，以证明你是某个公钥背后的 BTC 的所有者。但是，若想执行多签交易，你必须提供多个签名。这些签名会占据额外的空间。</p>
<p>以 12&#x2F;20 多签交易为例。12&#x2F;20 指的是执行该交易至少需要提供 20 个签名中的任意 12 个。签署交易时，签名也会存储在区块内。假设 1 个签名的大小是 5 字节，12 个签名需要占用区块 60 字节（5*12 &#x3D; 60）的内存，100 个签名需要占用 500 字节的内存。这会增加内存用量。Schnorr 签名恰好可以解决这一问题。</p>
<p>为了理解 Schnorr 签名，我们来看个例子：</p>
<p>多签交易。假设你需要 100 个签名且每个签名的大小是 5 字节，Schnorr 签名方案可以将这 100 个签名合并成一个大小为 64 字节的 Schnorr 签名。省下 436 字节（5*100-64&#x3D;436）的内存可以用来存储更多交易。（注：现在的椭圆曲线签名可不止 5 字节）</p>
<h5 id="Taproot"><a href="#Taproot" class="headerlink" title="Taproot"></a>Taproot</h5><p>沿用 Maxwell 原文中的例子：假设两个用户各有公钥 A、B，两人聚合公钥 A + B &#x3D; C，再生成最终公钥 P &#x3D; C + H(C||S)*G，其中 S 为自定义的脚本。就以这个最终公钥 P 来定义资金的解锁条件。假设两个用户都在线，他们很容易可以共同使用这笔资金，只要其中一方在签名时在自己的私钥里加上 H(C||S) 即可；如果只有其中一方在线，比如 S 定义了 B 可以花费资金的条件，Taproot 的规则使得公钥 B 用户可通过揭示聚合公钥 P 以及 H(C||S) 并提供可以满足 S 的条件来使用资金。</p>
<p>总而言之，在 Taproot 之后，他人将无法从地址形式上分辨一个 P2TR 地址到底是个人用户还是合约用户；由于 Schnorr 签名的效果，当这个地址里的资金使用单签名来解锁时，他人将无法分辨这到底是一个人在使用，还是 n 个人一起使用，也无法知道这个地址是否还有自定义的脚本；由于 MAST 的效果，当用户使用自定义的脚本来花费资金时，只需暴露需要用到的部分脚本；他人虽然知道了这个地址有自定义的脚本，但整个脚本到底包括哪些条件，仍然是不可知的。</p>
<p>具体技术实现与 segwit 相似，输出脚本改为 见证版本号改为 1 + MASK root 地址(32 Bytes)</p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/12/14/blockchain/btc/address/" data-id="cluyygvya000uj9psd2642ifs" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/btc-bitcoin/" rel="tag">btc,bitcoin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain/btc/ordinal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/12/14/blockchain/btc/ordinal/">Ordinals 协议 和 BRC-20</a>
    </h1>
  

        <a href="/2023/12/14/blockchain/btc/ordinal/" class="article-date">
  <time datetime="2023-12-14T15:25:59.000Z" itemprop="datePublished">2023-12-14</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>下文需要对 BTC 的交易模型有所了解，不知道的同学请先看: <a target="_blank" rel="noopener" href="https://madaolabs.github.io/2023/12/14/blockchain/btc/address/">《解读 BTC 的地址类型以及交易模型》</a></p>
<h4 id="Ordinals-协议是什么？"><a href="#Ordinals-协议是什么？" class="headerlink" title="Ordinals 协议是什么？"></a>Ordinals 协议是什么？</h4><p>Ordinals 做了两个事情：</p>
<ol>
<li>给每一个 satoshi 一个序号</li>
<li>将一段固定格式的文本结合<strong>序号</strong>。该文本叫做成为铭文（Inscriptions）并且数据存储在比特币 taproot script-path 花费脚本中。</li>
</ol>
<p>Ordinals Theory：Ordinals + Inscriptions &#x3D; Digital Artefacts。</p>
<h4 id="铸造过程"><a href="#铸造过程" class="headerlink" title="铸造过程"></a>铸造过程</h4><p>铸造的流程是一个固定的步骤分为两步(本质上是<strong>两笔交易</strong>):</p>
<ol>
<li>提交(commit)</li>
<li>揭露(reveal)</li>
</ol>
<p><strong>提交</strong>的交易必须由 bc1p 的地址发起，输出脚本(锁定脚本)是 Taproot 的脚本: 见证版本号 1 + MASK root 的公钥，得益于 Taproot 升级此时只能在脸上看到这笔交易，但无法看到交易的内容</p>
<p><strong>揭露</strong>的交易是消费上一笔交易的输出，在此交易中的输入包含了铭文数据，达到揭露的目的。</p>
<h4 id="Ordinal-的脚本格式"><a href="#Ordinal-的脚本格式" class="headerlink" title="Ordinal 的脚本格式"></a>Ordinal 的脚本格式</h4><p>OP_FALSE OP_IF … OP_ENDIF。 从 OP_IF 与 OP_ENDIF 之间的内容可以是任意内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OP_FALSE</span><br><span class="line">OP_IF</span><br><span class="line">  OP_PUSH &quot;ord&quot;</span><br><span class="line">  OP_PUSH 1</span><br><span class="line">  OP_PUSH &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">  OP_PUSH 0</span><br><span class="line">  OP_PUSH &quot;Hello, world!&quot;</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure>

<h4 id="Ordinals-的价值"><a href="#Ordinals-的价值" class="headerlink" title="Ordinals 的价值"></a>Ordinals 的价值</h4><p>Ordinals 的价值在于 satoshi 的稀有度，分为 6 种稀有：</p>
<ol>
<li>common: 不是区块第一个 sat 的任何 sat</li>
<li>uncommon: 每个区块的第一个 sat</li>
<li>rare: 每个难度调整期（每 2016 个区块调整 1 次）的第一个 sat</li>
<li>epic: 每个减半周期（大约每四年）的第一个 sat</li>
<li>legendary：每个周期（减半和难度调整同时发生）的第一个 sat</li>
<li>mythic: 创世块的第一个 sat</li>
</ol>
<h4 id="BRC-20"><a href="#BRC-20" class="headerlink" title="BRC-20"></a>BRC-20</h4><p>是一段 json 格式的固定文本, 目前仅有部署、铸造和转帐三种功能</p>
<h4 id="BRC-20-脚本案例"><a href="#BRC-20-脚本案例" class="headerlink" title="BRC-20 脚本案例"></a>BRC-20 脚本案例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OP_FALSE</span><br><span class="line">OP_IF</span><br><span class="line">  OP_PUSH &quot;ord&quot;</span><br><span class="line">  OP_PUSH 1</span><br><span class="line">  OP_PUSH &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">  OP_PUSH 0</span><br><span class="line">  OP_PUSH &quot;&#123;p: &quot;brc-20&quot;, op: &quot;deploy&quot;, tick: &quot;ordi&quot;, max: &quot;21000000&quot;, lim: &quot;1000&quot;&#125;&quot;</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure>

<h4 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h4><ol>
<li>提交：<a target="_blank" rel="noopener" href="https://www.blockchain.com/explorer/transactions/btc/43eed3dac6f11b4b8f1d5d85b15dbbbe76ed8240f3053d9c44123289ac720e5e">43eed…20e5e</a></li>
<li>接着提交揭露: <a target="_blank" rel="noopener" href="https://www.blockchain.com/explorer/transactions/btc/2911040743b16b71c4c00dc2561b91dac87650e0957d8acd016da0ffd8d3d511">29110…3d511</a></li>
</ol>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/12/14/blockchain/btc/ordinal/" data-id="cluyygvyb000wj9ps28b80vac" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BTC-Ordinal/" rel="tag">BTC, Ordinal</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain/consensus/POS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/24/blockchain/consensus/POS/">POS Consensus</a>
    </h1>
  

        <a href="/2023/10/24/blockchain/consensus/POS/" class="article-date">
  <time datetime="2023-10-24T13:54:33.000Z" itemprop="datePublished">2023-10-24</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Proof of Stake，股权证明<br>类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明 POS 模式下，有一个名词叫币龄，每个币每天产生 1 币龄，比如你持有 100 个币，总共持有了 30 天，那么，此时你的币龄就为 3000，这个时候，如果你发现了一个 POS 区块，你的币龄就会被清空为 0。你每被清空 365 币龄，你将会从区块中获得 0.05 个币的利息(假定利息可理解为年利率 5%)，那么在这个案例中，利息 &#x3D; 3000 * 5% &#x2F; 365 &#x3D; 0.41 个币，这下就很有意思了，持币有利息。以太坊就是采用 POS 共识算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;crypto/sha256&quot;</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;encoding/hex&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//实现pos挖矿的原理</span><br><span class="line"></span><br><span class="line">type Block struct &#123;</span><br><span class="line">	Index int</span><br><span class="line">	Data string //</span><br><span class="line">	PreHash string</span><br><span class="line">	Hash string</span><br><span class="line">	Timestamp string</span><br><span class="line">	//记录挖矿节点</span><br><span class="line">	Validator *Node</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func genesisBlock() Block  &#123;</span><br><span class="line"></span><br><span class="line">	var genesBlock  = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125;</span><br><span class="line">	genesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</span><br><span class="line">	return genesBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BlockHash(block *Block) []byte  &#123;</span><br><span class="line">	record := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]byte(record))</span><br><span class="line">	hashed := h.Sum(nil)</span><br><span class="line"></span><br><span class="line">	return hashed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建全节点类型</span><br><span class="line">type Node struct &#123;</span><br><span class="line">	Tokens int //持币数量</span><br><span class="line">	Days int //持币时间</span><br><span class="line">	Address string //地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建5个节点</span><br><span class="line">//算法的实现要满足 持币越多的节点越容易出块</span><br><span class="line">var nodes = make([]Node, 5)</span><br><span class="line">//存放节点的地址</span><br><span class="line">var addr = make([]*Node, 15)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func InitNodes()  &#123;</span><br><span class="line"></span><br><span class="line">	nodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125;</span><br><span class="line">	nodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125;</span><br><span class="line">	nodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125;</span><br><span class="line">	nodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125;</span><br><span class="line">	nodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125;</span><br><span class="line"></span><br><span class="line">	cnt :=0</span><br><span class="line">	for i:=0;i&lt;5;i++ &#123;</span><br><span class="line">		for j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</span><br><span class="line">			addr[cnt] = &amp;nodes[i]</span><br><span class="line">			cnt++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//采用Pos共识算法进行挖矿</span><br><span class="line">func CreateNewBlock(lastBlock *Block, data string) Block&#123;</span><br><span class="line"></span><br><span class="line">	var newBlock Block</span><br><span class="line">	newBlock.Index = lastBlock.Index + 1</span><br><span class="line">	newBlock.Timestamp = time.Now().String()</span><br><span class="line">	newBlock.PreHash = lastBlock.Hash</span><br><span class="line">	newBlock.Data = data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//通过pos计算由那个村民挖矿</span><br><span class="line">	//设置随机种子</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	//[0,15)产生0-15的随机值</span><br><span class="line">	var rd =rand.Intn(15)</span><br><span class="line"></span><br><span class="line">	//选出挖矿的旷工</span><br><span class="line">	node := addr[rd]</span><br><span class="line">	//设置当前区块挖矿地址为旷工</span><br><span class="line">	newBlock.Validator = node</span><br><span class="line">	//简单模拟 挖矿所得奖励</span><br><span class="line">	node.Tokens += 1</span><br><span class="line">	newBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</span><br><span class="line">	return newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">	InitNodes()</span><br><span class="line"></span><br><span class="line">	//创建创世区块</span><br><span class="line">	var genesisBlock = genesisBlock()</span><br><span class="line"></span><br><span class="line">	//创建新区快</span><br><span class="line">	var newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;)</span><br><span class="line"></span><br><span class="line">	//打印新区快信息</span><br><span class="line">	fmt.Println(newBlock)</span><br><span class="line">	fmt.Println(newBlock.Validator.Address)</span><br><span class="line">	fmt.Println(newBlock.Validator.Tokens)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/10/24/blockchain/consensus/POS/" data-id="cluyygvyd0012j9psghk585ur" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain/consensus/PBFT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/23/blockchain/consensus/PBFT/">PBFT Consensus</a>
    </h1>
  

        <a href="/2023/10/23/blockchain/consensus/PBFT/" class="article-date">
  <time datetime="2023-10-23T15:42:36.000Z" itemprop="datePublished">2023-10-23</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>PBFT 是共识算法中的一种实现，主要应用在节点较少的情况下。联盟链中使用这样的共识算法居多。下面有图和实现代码：</p>
<p><img src="/2023/10/23/blockchain/consensus/PBFT/pbft.png"></p>
<h3 id="PBFT-的重点在于："><a href="#PBFT-的重点在于：" class="headerlink" title="PBFT 的重点在于："></a>PBFT 的重点在于：</h3><p>PBFT 容忍无效或者恶意节点数：f，为了保障整个系统可以正常运转，需要有 2f+1 个正常节点，系统的总节点数为：|R| &#x3D; 3f + 1。也就是说，PBFT 算法可以容忍小于 1&#x2F;3 个无效或者恶意节点。也就是说在超过 1&#x2F;3 ｜ R ｜ 个节点确认之后，就认为是没有问题的。如以下代码 <strong>132</strong> 行所展现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明节点信息,代表各个小国家</span><br><span class="line">type nodeInfo struct &#123;</span><br><span class="line">	//标示</span><br><span class="line">	id string</span><br><span class="line">	//准备访问的方法</span><br><span class="line">	path string</span><br><span class="line">	//服务器做出的相应</span><br><span class="line">	writer http.ResponseWriter</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//存放四个国家的地址</span><br><span class="line">var nodeTable = make(map[string]string)</span><br><span class="line"></span><br><span class="line">//拜占庭在Fabric中的使用</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	//获取执行的参数</span><br><span class="line">	userId :=os.Args[1]//获取执行的第一个参数</span><br><span class="line">	fmt.Println(userId)</span><br><span class="line"></span><br><span class="line">	//./main Apple</span><br><span class="line"></span><br><span class="line">	//创建四个国家的地址</span><br><span class="line">	nodeTable = map[string]string &#123;</span><br><span class="line">		&quot;Apple&quot;:&quot;localhost:1111&quot;,</span><br><span class="line">		&quot;MS&quot;:&quot;localhost:1112&quot;,</span><br><span class="line">		&quot;Google&quot;:&quot;localhost:1113&quot;,</span><br><span class="line">		&quot;IBM&quot;:&quot;localhost:1114&quot;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node:=nodeInfo&#123;userId,nodeTable[userId],nil&#125;</span><br><span class="line">	fmt.Println(node)</span><br><span class="line"></span><br><span class="line">	//http协议的回调函数</span><br><span class="line">	//http://localhost:1111/req?warTime=8888</span><br><span class="line">	http.HandleFunc(&quot;/req&quot;,node.request)</span><br><span class="line">	http.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare)</span><br><span class="line">	http.HandleFunc(&quot;/prepare&quot;,node.prepare)</span><br><span class="line">	http.HandleFunc(&quot;/commit&quot;,node.commit)</span><br><span class="line"></span><br><span class="line">	//启动服务器</span><br><span class="line">	if err:=http.ListenAndServe(node.path,nil);err!=nil &#123;</span><br><span class="line">		fmt.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此函数是http访问时候req命令的请求回调函数</span><br><span class="line">func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line">	//设置允许解析参数</span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//如果有参数值，则继续处理</span><br><span class="line">	if (len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</span><br><span class="line">		node.writer = writer</span><br><span class="line">		//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//由主节点向其他节点做广播</span><br><span class="line">func (node *nodeInfo)broadcast(msg string ,path string )&#123;</span><br><span class="line">	//遍历所有的国家</span><br><span class="line">	for nodeId,url:=range nodeTable &#123;</span><br><span class="line"></span><br><span class="line">		if nodeId == node.id &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		//调用Get请求</span><br><span class="line">		//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</span><br><span class="line">		http.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//fmt.Println(&quot;hello world&quot;)</span><br><span class="line">	//在做分发</span><br><span class="line">	if(len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</span><br><span class="line">		//分发给其他三个人</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">	request.ParseForm()</span><br><span class="line">	//调用验证</span><br><span class="line">	if len(request.Form[&quot;warTime&quot;])&gt;0&#123;</span><br><span class="line">		fmt.Println(request.Form[&quot;warTime&quot;][0])</span><br><span class="line">	&#125;</span><br><span class="line">	if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</span><br><span class="line">		fmt.Println(request.Form[&quot;nodeId&quot;][0])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node.authentication(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var authenticationsuccess = true</span><br><span class="line">var authenticationMap = make(map[string]string)</span><br><span class="line">//获得除了本节点外的其他节点数据</span><br><span class="line">func (node *nodeInfo)authentication(request *http.Request) &#123;</span><br><span class="line"></span><br><span class="line">	//接收参数</span><br><span class="line">	request.ParseForm()</span><br><span class="line"></span><br><span class="line">	if authenticationsuccess!=false  &#123;</span><br><span class="line">		if len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</span><br><span class="line">			authenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(authenticationMap)&gt;len(nodeTable)/3 &#123;</span><br><span class="line">		//则拜占庭原理实现,通过commit反馈给浏览器</span><br><span class="line">		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123;</span><br><span class="line"></span><br><span class="line">	//给浏览器反馈相应</span><br><span class="line">	io.WriteString(node.writer,&quot;ok&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/10/23/blockchain/consensus/PBFT/" data-id="cluyygvyb000yj9psdazf7ior" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-frontend/learnCodeLanguage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/10/09/frontend/learnCodeLanguage/">如何快速掌握一门编程语言</a>
    </h1>
  

        <a href="/2023/10/09/frontend/learnCodeLanguage/" class="article-date">
  <time datetime="2023-10-09T08:39:30.000Z" itemprop="datePublished">2023-10-09</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>在使用了众多语言后，整理一些语言学习的框架，可以指导自己快速上手。</p>
<ol>
<li>数据类型( 字面量 和 显示声明 )<ol>
<li>number,</li>
<li>string,</li>
<li>char,</li>
<li>boolean,</li>
<li>array</li>
<li>tuple,</li>
<li>set,</li>
<li>map<br>更多…</li>
</ol>
</li>
<li>变量的定义</li>
<li>方法声明与使用</li>
<li>流程控制<ol>
<li>ifelse</li>
<li>loop</li>
<li>match</li>
</ol>
</li>
<li>模块和类</li>
</ol>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/10/09/frontend/learnCodeLanguage/" data-id="cluyygvxw0007j9psfea9877v" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rust/trait" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/27/rust/trait/">Trait</a>
    </h1>
  

        <a href="/2023/09/27/rust/trait/" class="article-date">
  <time datetime="2023-09-27T13:40:06.000Z" itemprop="datePublished">2023-09-27</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>trait 和 trait object（特征对象）<br>特征对象表示：实现了某个特征的实例, 比如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;f64: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box&lt;T&gt; 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw&gt;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw1</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    <span class="comment">// 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法</span></span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw2</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="comment">// do_something(&amp;x);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box&lt;T&gt; 可以在函数调用时隐式地被转换为特征对象 Box&lt;dyn Draw&gt;</span></span><br><span class="line">    <span class="comment">// 基于 x 的值创建一个 Box&lt;f64&gt; 类型的智能指针，指针指向的数据被放置在了堆上</span></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x));</span><br><span class="line">    <span class="comment">// 基于 y 的值创建一个 Box&lt;u8&gt; 类型的智能指针</span></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(y));</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;x);</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/09/27/rust/trait/" data-id="cluyygvy8000nj9pscctw2hke" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rust/closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/27/rust/closure/">Closure</a>
    </h1>
  

        <a href="/2023/09/27/rust/closure/" class="article-date">
  <time datetime="2023-09-27T11:35:01.000Z" itemprop="datePublished">2023-09-27</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>有些语言中没有 closure 和普通函数的区分，但 Rust 有。对 Rust 来说普通函数就是一段代码。而 closure 和 C++ 类似：每个 closure 会创建一个匿名的 struct，编译器会在当前上下文捕获 closure 代码中的外部变量然后塞进这个<strong>结构体</strong>里面。</p>
<p>为什么要有闭包？<br>在 rust 中函数是不能捕获<strong>动态环境变量</strong>，这是因为在 Rust 中，函数是静态的，而不是动态的。函数定义时，所有的变量和参数都必须是已知的、固定的值。这意味着，函数不能从其所在的环境中捕获任何动态变量。而闭包可以。下面展示使用函数调用作用域变量的错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">equal_to_x</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; z == x &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法通过编译</span></span><br><span class="line"></span><br><span class="line">error[E0434]: can<span class="symbol">&#x27;t</span> capture dynamic environment <span class="keyword">in</span> a <span class="keyword">fn</span> <span class="title function_">item</span>; <span class="keyword">use</span> the || &#123; ...</span><br><span class="line">&#125; closure form instead</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs</span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">fn</span> <span class="title function_">equal_to_x</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; z == x &#125;</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>

<p>闭包是可以捕获环境变量的，捕获的方式有 3 种<strong>Trait</strong>：FnOnce, FnMut, Fn</p>
<p>FnOnce 表示：捕获到的环境变量<strong>所有值转移</strong><br>FnMut 表示：捕获到的环境变量<strong>可变借用</strong><br>Fn 表示：捕获到的环境变量<strong>不可变借用</strong></p>
<p>上面所说的并不是绝对的，注意：<strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们</strong>，入下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> =  <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然声明了特征值：FnOnce，但是内部使用的是不可变借用，所以该闭包也实现了 Fn 特征。所以上面的代码: FnOnce 改为 Fn 也是可以的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> =  <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/09/27/rust/closure/" data-id="cluyygvy6000hj9ps2cbhe7al" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-knowledgeOfComputer/secp256k1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/26/knowledgeOfComputer/secp256k1/">以太坊中的secp256k1</a>
    </h1>
  

        <a href="/2023/09/26/knowledgeOfComputer/secp256k1/" class="article-date">
  <time datetime="2023-09-26T17:05:23.000Z" itemprop="datePublished">2023-09-26</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p>非对称加密在工作中是经常用到的，比如有 RSA，ED25519，secp256k1.</p>
<p>在区块链生态大多数公链使用的 secp256k1, 比如：eth。除此之外也有少数公链使用的 ed25519，比如：solana.</p>
<p>通常在非对称加密我们使用私钥签名，用公钥验证。secp256k1 可以在不知道公钥的情况下验证：通过<strong>签名结果</strong>+<strong>原数据</strong>可以得出<strong>公钥</strong>来。</p>
<p>secp256k1 整体流程：</p>
<ol>
<li>生成公私钥</li>
<li>公钥 -&gt; 地址：keccak256(公钥)取后 20 位就是地址</li>
<li>私钥签名: 在 sepc256k1 中，使用私钥签名，签名结果 65 字节，可以分为：r，s，v。r: 32 字节, s: 32 字节，v: 1 字节。<br>在 EVM 中：<br>signature &#x3D; r+s<br>recovery &#x3D; v + 27;</li>
<li>还原公钥：根据 message(原数据) + signature + recovery</li>
</ol>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/09/26/knowledgeOfComputer/secp256k1/" data-id="cluyygvy2000cj9ps2mj30jqs" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-book/startup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/10/book/startup/">创业分析</a>
    </h1>
  

        <a href="/2023/09/10/book/startup/" class="article-date">
  <time datetime="2023-09-10T09:20:42.000Z" itemprop="datePublished">2023-09-10</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<p><img src="/2023/09/10/book/startup/startup_first.png"></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://blog.madaotech.top/2023/09/10/book/startup/" data-id="cluyygvxp0002j9ps97ay5ghp" class="article-share-link">Share</a>-->
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024, Madaolabs<br />
      <!-- Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a> -->
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.loli.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

 
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
 
<script src="/fancybox/jquery.fancybox.pack.js"></script>
  
<script src="/js/script.js"></script>
 


  </div>
</body>
</html>