<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    
 
    <title>interview | Madaolabs</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <meta name="description" content="知识点考察1. redux-thunk 和 redux-saga 的区别redux-thunk 处理 side effect 的方式是：dispatch 一个对象时不做处理；dispatch 一个函数，在函数中处理异步动作，然后再 dispatch 一个对象 redux-saga 处理 side effect 的方式是：自行建立了一套事件监听机制，接管所有的 action。effects 方法有">
<meta property="og:type" content="article">
<meta property="og:title" content="interview">
<meta property="og:url" content="https://blog.madaotech.top/2023/07/11/frontend/interview/index.html">
<meta property="og:site_name" content="Madaolabs">
<meta property="og:description" content="知识点考察1. redux-thunk 和 redux-saga 的区别redux-thunk 处理 side effect 的方式是：dispatch 一个对象时不做处理；dispatch 一个函数，在函数中处理异步动作，然后再 dispatch 一个对象 redux-saga 处理 side effect 的方式是：自行建立了一套事件监听机制，接管所有的 action。effects 方法有">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-11T08:23:30.000Z">
<meta property="article:modified_time" content="2023-09-03T07:09:36.161Z">
<meta property="article:tag" content="frontend">
<meta name="twitter:card" content="summary">  
    <link rel="icon" href="/favicon.ico" />
     
    <link
      href="//fonts.loli.net/css?family=Source+Code+Pro"
      rel="stylesheet"
      type="text/css"
    />
    
    <link
      href="https://fonts.loli.net/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean"
      rel="stylesheet"
    />
    
<link rel="stylesheet" href="/css/style.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
</html>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"> </a>
        <a href="/" id="main-nav-title" class="main-nav-link">
          Madaolabs</a
        >
        
        <a class="main-nav-link" href="/archives/"
          >Archives</a
        >
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-frontend/interview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      interview
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识点考察"><a href="#知识点考察" class="headerlink" title="知识点考察"></a>知识点考察</h1><h3 id="1-redux-thunk-和-redux-saga-的区别"><a href="#1-redux-thunk-和-redux-saga-的区别" class="headerlink" title="1. redux-thunk 和 redux-saga 的区别"></a>1. redux-thunk 和 redux-saga 的区别</h3><p>redux-thunk 处理 side effect 的方式是：dispatch 一个对象时不做处理；dispatch 一个函数，在函数中处理异步动作，然后再 dispatch 一个对象</p>
<p>redux-saga 处理 side effect 的方式是：自行建立了一套事件监听机制，接管所有的 action。effects 方法有 take, put, call, select, fork, takeEvery, takeLatest</p>
<h3 id="2-高阶函数和闭包"><a href="#2-高阶函数和闭包" class="headerlink" title="2. 高阶函数和闭包"></a>2. 高阶函数和闭包</h3><p>高阶函数的概念：一个函数的参数能够接受另一个函数作为参数，称之为高阶函数</p>
<p>闭包的概念：是通过函数返回函数的的方式，改变 JS 的回收机制</p>
<h3 id="3-redux-sage-中涉及了-generator"><a href="#3-redux-sage-中涉及了-generator" class="headerlink" title="3. redux-sage 中涉及了 generator"></a>3. redux-sage 中涉及了 generator</h3><p>生成器函数处理循环流程中控制各个步骤的呈现方式非常厉害，如：实现点击按钮，把逐个往同一类元素上添加 className</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strings = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.string&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> className = <span class="string">&quot;darker&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">addClassToEach</span>(<span class="params">elements, className</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(elements)) <span class="keyword">yield</span> el.<span class="property">classList</span>.<span class="title function_">add</span>(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addClassToStrings = <span class="title function_">addClassToEach</span>(strings, className);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!addClassToStrings.<span class="title function_">next</span>().<span class="property">done</span>) el.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">add</span>(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>  不用递归实现菲波那切数列，用生成器函数实现
</code></pre>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fabonacci</span>(<span class="params">seed1, seed2</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> () =&gt; &#123;</span><br><span class="line">      seed2 = seed1 + seed2;</span><br><span class="line">      seed1 = seed2 - seed1;</span><br><span class="line">      <span class="keyword">return</span> seed2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Promise"><a href="#4-Promise" class="headerlink" title="4. Promise"></a>4. Promise</h3><p>为什么使用 Promise？</p>
<p>promise 的功能是可以将复杂的异步处理轻松地进行模式化</p>
<p>Promise 的并发控制</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/felance/sfhx1u/gz8ogd">https://www.yuque.com/felance/sfhx1u/gz8ogd</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LimitPromise</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">max</span>)&#123;</span><br><span class="line">		<span class="comment">// 最多执行的任务个数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max;</span><br><span class="line">    <span class="comment">// 当前正在执行的任务个数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">call</span>(<span class="params">caller, ...args</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> task = <span class="variable language_">this</span>.<span class="title function_">createTask</span>(caller, args, resolve, reject);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt;= <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(task);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">task</span>()</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">createTask</span>(caller, args, resolve, reject) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">			<span class="title function_">caller</span>(...args)</span><br><span class="line">						.<span class="title function_">then</span>(resolve)</span><br><span class="line">						.<span class="title function_">catch</span>(reject)</span><br><span class="line">						.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">							<span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">							<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">								<span class="keyword">const</span> task = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">		            <span class="title function_">task</span>();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-节流函数"><a href="#5-节流函数" class="headerlink" title="5. 节流函数"></a>5. 节流函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, duration，delay = <span class="number">100</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>, begin = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        current = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (current - begin &gt; duration) &#123;</span><br><span class="line">            <span class="title function_">func</span>();</span><br><span class="line">            begin=current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(func, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="title function_">throttle</span>(handler, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-面试知识点"><a href="#6-面试知识点" class="headerlink" title="6. 面试知识点"></a>6. 面试知识点</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenwenhao/p/11267238.html">https://www.cnblogs.com/chenwenhao/p/11267238.html</a></p>
<h3 id="7-原型链"><a href="#7-原型链" class="headerlink" title="7. 原型链"></a>7. 原型链</h3><ol>
<li><p>什么是构造函数？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A是一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型对象 <strong>原型对象的意义是 原型对象是子函数可以访问到的区域，可以实现继承。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.prototype是原型对象</span></span><br><span class="line"><span class="comment">// 原型对象有属性</span></span><br><span class="line">		constructor：指向构造函数,</span><br><span class="line">		__proto__：指向父节点的prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a是实例对象</span></span><br><span class="line"><span class="comment">// 实例对象的__proto__属性 === 构造函数的prototype，即 a.__proto__ === A.prototype</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型链就是<strong>proto</strong>指向，层层指向，知道为 null 到头</p>
</li>
</ol>
<h3 id="8-js-继承"><a href="#8-js-继承" class="headerlink" title="8. js 继承"></a>8. js 继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链结合构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure>

<h3 id="9-Express-和-Koa-的中间件模型有什么区别"><a href="#9-Express-和-Koa-的中间件模型有什么区别" class="headerlink" title="9. Express 和 Koa 的中间件模型有什么区别"></a>9. Express 和 Koa 的中间件模型有什么区别</h3><p>Express 中间件模型是线性模型，中间件的执行过程没有对 async，await 做处理</p>
<p>Koa2 中间件模型是洋葱模型，中间件的执行返回了 Promise 对象</p>
<h3 id="10-http-属性中控制缓存的哪些？"><a href="#10-http-属性中控制缓存的哪些？" class="headerlink" title="10.http 属性中控制缓存的哪些？"></a>10.http 属性中控制缓存的哪些？</h3><p>浏览器请求数据时经历的流程：1.强制缓存，2.协商缓存，3 请求</p>
<p>1.强制缓存响应的 header 中有 Expires&#x2F;Cache-control</p>
<p><strong>Cache-Control 优先级大于 Expires</strong></p>
<p>Expires 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。</p>
<p>Cache-Control 是最重要的规则。常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。</p>
<p>private:  客户端可以缓存</p>
<p>public:  客户端和代理服务器都可缓存（前端的同学，可以认为 public 和 private 是一样的）</p>
<p>max-age&#x3D;xxx:  缓存的内容将在 xxx 秒后失效</p>
<p>no-cache:  需要使用协商缓存来验证缓存数据（后面介绍）</p>
<p>no-store:  所有内容都不会缓存，强制缓存，协商缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说 886）</p>
<p>2.协商缓存</p>
<p>此时的状态码为 304。</p>
<p>方案有 2 种：</p>
<p>1.Last-Modified&#x2F;If-Modified-Since</p>
<p>第一次请求响应的 header 中有 Last-Modified 字段，值为时间。再次请求时 request 的 header 中有 If-Modified-Since</p>
<p>2.Etag&#x2F;If-None-Match</p>
<p>响应 header 中有 Etag 字段，值为唯一标识码，请求 header 的 If-None-Match 携带改字段</p>
<p><strong>Etag&#x2F;If-None-Match 优先级大于 Last-Modified&#x2F;If-Modified-Since</strong></p>
<h3 id="11-变量，函数提升"><a href="#11-变量，函数提升" class="headerlink" title="11.变量，函数提升"></a><strong>11.变量，函数提升</strong></h3><p>变量提升是使用 var 定义的变量，会把 var 的<strong>声明</strong>提升到作用域最前面</p>
<p>函数的提升是吧 function 提升到作用域最前面</p>
<h3 id="12-new-之后发生了什么事情，如何不用-new-创建实例对象"><a href="#12-new-之后发生了什么事情，如何不用-new-创建实例对象" class="headerlink" title="12. new 之后发生了什么事情，如何不用 new 创建实例对象"></a><strong>12. new 之后发生了什么事情，如何不用 new 创建实例对象</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">Func, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Func</span>.<span class="title function_">call</span>(obj, ...args);</span><br><span class="line">  <span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-ES6-和-ES5-有什么区别"><a href="#13-ES6-和-ES5-有什么区别" class="headerlink" title="13.ES6 和 ES5 有什么区别"></a>13.ES6 和 ES5 有什么区别</h3><ol>
<li>块级作用域(let 和 const)</li>
<li>箭头函数<ol>
<li>箭头函数使用 bind，call，apply 传入的 this 是没有效果的</li>
</ol>
</li>
<li>解构(数组解构，对象解构)</li>
<li>class extends super</li>
<li>生成器</li>
<li>Promise</li>
<li>Map 和 Object 有什么不同：<ol>
<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>
<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算</li>
</ol>
</li>
</ol>
<h3 id="14-排序算法"><a href="#14-排序算法" class="headerlink" title="14. 排序算法"></a>14. 排序算法</h3><ol>
<li><p><strong>选择排序</strong></p>
<p>选择排序是一个简单直观的排序方法，它的工作原理很简单，首先从未排序序列中找到最大的元素，放到已排序序列的末尾，重复上述步骤，直到所有元素排序完毕。</p>
<p>时间复杂度 O(n^2), 空间复杂度 O(1);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &lt; arr[j]) &#123;</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = arr[index];</span><br><span class="line">      arr[index] = arr[i];</span><br><span class="line">      arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>快速排序</strong></p>
</li>
</ol>
<p>快速排序的算法思想是选择一个值，把小于这个值的放在左边，大于这个值得放在右边</p>
<p>时间复杂度: O(nlogn)<br>空间复杂度: O()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> leftArr = [];</span><br><span class="line">  <span class="keyword">var</span> rightArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">      leftArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rightArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(leftArr).<span class="title function_">concat</span>([arr[<span class="number">0</span>]], <span class="title function_">quickSort</span>(rightArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 冒泡排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-js-的垃圾回收机制，有怎样的问题"><a href="#15-js-的垃圾回收机制，有怎样的问题" class="headerlink" title="15. js 的垃圾回收机制，有怎样的问题"></a>15. js 的垃圾回收机制，有怎样的问题</h3><pre><code>JavaScript中有两种垃圾回收策略，标记清除和引用计数
</code></pre>
<p>1、标记清除法：</p>
<pre><code>  [javascript](http://lib.csdn.net/base/javascript)最常用的垃圾收集方式。当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。可以使用一个“进入环境”的变量列表及一个“离开环境”的变量列表来跟踪变量的变化，也可以翻转某个特殊的位来记录一个变量何时进入环境及离开环境。
</code></pre>
<ol start="2">
<li><p>引用计数</p>
<p>不太常见的垃圾收集策略。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是 1；如果同一个值又被赋给另一个变量，则该值的引用次数加 1；如果包含对该值引用的变量又取得了另外一个值，则该值的引用次数减 1。当该值的引用次数变为 0 时，则可以回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为 0 的值所占用的内存。</p>
</li>
</ol>
<p>问题：循环引用</p>
<p>循环引用可以使用第三方的 JSON.recycle 来解决，核心原理是使用 WeakMap 来解决</p>
<h3 id="16-手写-Promise-的的关键特点"><a href="#16-手写-Promise-的的关键特点" class="headerlink" title="16. 手写 Promise 的的关键特点"></a>16. 手写 Promise 的的关键特点</h3><p>Promise 中的 then 方法中返回的是一个新的 Promise，在 Promise 中使用的的 setTimeout 来实现异步</p>
<h3 id="17-高阶组件的属性代理，反向继承"><a href="#17-高阶组件的属性代理，反向继承" class="headerlink" title="17. 高阶组件的属性代理，反向继承"></a>17. 高阶组件的属性代理，反向继承</h3><p>属性代理：参数为组件，返回值为新组件的函数</p>
<p>反向继承：反向继承最核心的两个作用，一个是渲染劫持，另一个是操作 state 吧。反向继承有两种写法，两种写法存在不同的能力</p>
<p>反向继承是通过传进去参数是组件，然后继承该组件后重写，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">imoprt <span class="title class_">ComponentChild</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentChild.js&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">iihoc</span> = <span class="title class_">WrapComponet</span> =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrapComponet</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	    <span class="variable language_">super</span>(props)</span><br><span class="line">	    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">num</span>: <span class="number">2000</span></span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iihoc componentDidMount&#x27;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">clickComponent</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickComponent&#125;</span>&gt;</span>iiHoc 点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">iihoc</span>(<span class="title class_">ComponentChild</span>)</span><br></pre></td></tr></table></figure>

<h3 id="18-实现-add-1-2-3"><a href="#18-实现-add-1-2-3" class="headerlink" title="18. 实现 add(1)(2)(3)()"></a>18. 实现 add(1)(2)(3)()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span>(<span class="params">...argv</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argv.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...argv];</span><br><span class="line">      <span class="keyword">return</span> _c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">add</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-JavaScript-深入之作用域链"><a href="#19-JavaScript-深入之作用域链" class="headerlink" title="19. JavaScript 深入之作用域链"></a>19. JavaScript 深入之作用域链</h3><h3 id="20-DOM-事件等级"><a href="#20-DOM-事件等级" class="headerlink" title="20. DOM 事件等级"></a>20. DOM 事件等级</h3><h3 id="21-useCallback-和-useMemo"><a href="#21-useCallback-和-useMemo" class="headerlink" title="21. useCallback 和 useMemo"></a>21. useCallback 和 useMemo</h3><p>React.memo(fn, fn(prevPros, nextProps))</p>
<p>useCallback(fn, [])</p>
<p>useCallback 和 React.memo 用于缓存函数</p>
<p>useMemo(fn, [])用于缓存值</p>
<h3 id="22-React-的-diff-算法"><a href="#22-React-的-diff-算法" class="headerlink" title="22. React 的 diff 算法"></a>22. React 的 diff 算法</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039021724">https://segmentfault.com/a/1190000039021724</a><br>React 分为两个方法处理：reconcileSingleElement 和 reconcileChildrenArray</p>
<p>diff 算法应对三种场景：节点更新、节点增删、节点移动</p>
<p>单节点：单节点更新、单节点增删。</p>
<p>多节点：多节点更新、多节点增删、多节点移动。</p>
<p>节点的更新是 tag 和 key 相同的情况下，属性发了变化</p>
<p>多节点的比较最多遍历 3 次新节点，</p>
<p>第一次遍历针对节点自身属性更新，剩下的两轮依次处理节点的新增、移动</p>
<p>其中移动的算法比较复杂，这里说明一下：</p>
<p>在第一次遍历中，我们确定了 oldFider 和 newElements 中分别的的固定节点的位置（lastPlacedIndex）为最后一个更新节点的 index</p>
<p>移动的时候会将剩余的 oldFiber 节点放入一个以 key 为键，值为 oldFiber 节点的 map 中。称为 existingChildren<br>然后遍历新节点，根据每一个新节点找到 oldFiber 中的节点 index，和 lastPlaceIndex 比较，在 oldFiber 和 newElements 中如果 lastPlaceIndex &lt; index, 不移动，lastPlaceIndex 更新，<br>否则判断 oldFiber 和 newElements 中一个大于，一个小于，则移动</p>
<h3 id="23-什么是-React-的-fiber"><a href="#23-什么是-React-的-fiber" class="headerlink" title="23. 什么是 React 的 fiber"></a>23. 什么是 React 的 fiber</h3><p>fiber 是 React 在 V16 之后引入，在这之前组件的渲染是通过一次性全部渲染，在组件数很多的时候，渲染时间比较长，如果用户在此时输入，则会明显感受到卡顿。</p>
<p>解决这个问题的方法就是分片，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短。维护每一个分片的数据结构，就是 Fiber。</p>
<h3 id="24-页面优化手段有哪些"><a href="#24-页面优化手段有哪些" class="headerlink" title="24. 页面优化手段有哪些"></a>24. 页面优化手段有哪些</h3><ol>
<li>资源压缩，减少 http 请求<ol>
<li>图片懒加载：将图片地址先用 data-src 属性保存，监听 scroll，显示的时候在再加图片</li>
<li></li>
</ol>
</li>
<li>非核心代码异步加载<ol>
<li>defer: 在 HTML 解析完之后才会执行。如果是多个，则按照加载的顺序依次执行</li>
<li>async: 在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。</li>
</ol>
</li>
<li>浏览器缓存<ol>
<li>Response header Cache-Control: public, private, no-cache, no-store, max-age&#x3D;30s</li>
<li>Response header Expires</li>
<li>Etag 和 If-None-Match</li>
<li>Last-Modified 和 If-Modified-Since</li>
</ol>
</li>
<li>使用 CDN</li>
</ol>
<h3 id="25-前端安全"><a href="#25-前端安全" class="headerlink" title="25. 前端安全"></a>25. 前端安全</h3><ol>
<li><p>CSRF</p>
</li>
<li><p>XSS</p>
</li>
</ol>
<h3 id="26-浏览器-JS-事件循环"><a href="#26-浏览器-JS-事件循环" class="headerlink" title="26. 浏览器 JS 事件循环"></a>26. 浏览器 JS 事件循环</h3><ol>
<li>宏任务<ol>
<li>JS 代码</li>
<li>setTimeout</li>
<li>setInterval</li>
</ol>
</li>
<li>微任务<ol>
<li>Promise.then</li>
</ol>
</li>
</ol>
<p>每次执行完一个宏任务后，就会把微任务队列里的东西都执行完</p>
<p>这里要特别强调一下 async 和 await 的 js 执行</p>
<p>我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async&#x2F;await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？</p>
<h4 id="await-做了什么呢？"><a href="#await-做了什么呢？" class="headerlink" title="await 做了什么呢？"></a>await 做了什么呢？</h4><p>从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。</p>
<p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，<strong>实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍</strong>，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&#x27;async1 start&#x27;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#x27;async1 end&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&#x27;async1 start&#x27;);</span><br><span class="line">    Promise.resolve(async2()).then(() =&gt; &#123;</span><br><span class="line">                console.log(&#x27;async1 end&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典面试题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">c</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1-1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;settimeout1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2-1&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2-2&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;settimeout2&quot;</span>);</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise-reject&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;200&quot;</span>);</span><br><span class="line"><span class="title function_">b</span>();</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">步骤讲解：</span><br><span class="line"><span class="number">1</span>、从上自下执行， <span class="keyword">new</span> <span class="title class_">Promise</span> 函数立即执行              打印 ：promise2   一</span><br><span class="line"><span class="number">2</span>、<span class="title function_">resolve</span>()   将  promise2-<span class="number">2</span>   放入微任务队列中</span><br><span class="line"><span class="number">3</span>、继续向下执行                                       打印 ：promise2-<span class="number">1</span>  二</span><br><span class="line"><span class="number">4</span>、settimeout2放入宏任务队列</span><br><span class="line"><span class="number">5</span>、继续执行、无立即执行                                  打印 ：<span class="number">200</span>       三</span><br><span class="line"><span class="number">6</span>、执行  <span class="title function_">b</span>() 函数                                              打印 ：b  四</span><br><span class="line"><span class="number">7</span>、执行  <span class="keyword">await</span> <span class="title function_">c</span>() 函数                                        打印：c   五</span><br><span class="line"><span class="number">8</span>、进入 <span class="keyword">await</span> <span class="title function_">c</span>() 函数  中  nen <span class="title class_">Promise</span> 函数             打印 ：promise1  六</span><br><span class="line"><span class="number">9</span>、<span class="title function_">resolve</span>()   将  promise1-<span class="number">1</span>   放入微任务队列中</span><br><span class="line"><span class="number">10</span>、settimeout1  放入宏任务队列</span><br><span class="line"><span class="number">11</span>、暂无执行任务   去微任务中 执行第一个进入微任务的待执行动作  打印：promise2-<span class="number">2</span>   七</span><br><span class="line"><span class="number">12</span>、继续执行微任务中序列中待执行动作                           打印：promise1-<span class="number">1</span>  八</span><br><span class="line"><span class="number">13</span>、微任务中暂无执行 动作 继续执行  <span class="title function_">c</span>()  函数中的待执行代码            打印：c1    九</span><br><span class="line"><span class="number">14</span>、<span class="title function_">c</span>() 执行完毕，继续执行 <span class="title function_">b</span>() 函数中待执行代码                         打印：b1  十</span><br><span class="line"><span class="number">15</span>、至此，立即执行以微任务执行完毕，执行宏任务队列中第一个进入的待执行任务       打印 ：settimeout2   十一</span><br><span class="line"><span class="number">16</span>、宏任务一中，执行 <span class="keyword">new</span> <span class="title class_">Promise</span>  函数    <span class="title function_">resolve</span>()   将问号 放入微任务中   立即执行微任务  打印：？ 十二</span><br><span class="line"><span class="number">17</span>、继续执行宏任务中待执行动作                                                 打印：settimeout1   十三</span><br></pre></td></tr></table></figure>

<h3 id="27-setState-是异步还是同步"><a href="#27-setState-是异步还是同步" class="headerlink" title="27. setState 是异步还是同步"></a>27. setState 是异步还是同步</h3><p>我的回答是执行过程代码同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，所以表现出来有时是同步，有时是“异步”。</p>
<p>只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout&#x2F;setInterval 等原生 API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。</p>
<p>为什么会有这种现象呢？我们通过 React 版本 18.0.0-rc.2 找找原因<br>原因是在调用 setState 之后，对于由合成时间和钩子函数发起的 setState 与原生事件发起的 setState，处理不同，原生事件是直接处理，而合成事件是事件方法结束后，再执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ensureRootIsScheduled</span>(root, eventTime);</span><br><span class="line"><span class="comment">// 以下代码判断如果不是合成事件的处理</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  lane === <span class="title class_">SyncLane</span> &amp;&amp;</span><br><span class="line">  executionContext === <span class="title class_">NoContext</span> &amp;&amp;</span><br><span class="line">  (fiber.<span class="property">mode</span> &amp; <span class="title class_">ConcurrentMode</span>) === <span class="title class_">NoMode</span> &amp;&amp;</span><br><span class="line">  <span class="comment">// Treat `act` as if it&#x27;s inside `batchedUpdates`, even in legacy mode.</span></span><br><span class="line">  !(__DEV__ &amp;&amp; <span class="title class_">ReactCurrentActQueue</span>.<span class="property">isBatchingLegacy</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// Flush the synchronous work now, unless we&#x27;re already working or inside</span></span><br><span class="line">  <span class="comment">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span></span><br><span class="line">  <span class="comment">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span></span><br><span class="line">  <span class="comment">// without immediately flushing it. We only do this for user-initiated</span></span><br><span class="line">  <span class="comment">// updates, to preserve historical behavior of legacy mode.</span></span><br><span class="line">  <span class="title function_">resetRenderTimer</span>();</span><br><span class="line">  <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-JS-判断数据类型的方法"><a href="#28-JS-判断数据类型的方法" class="headerlink" title="28. JS 判断数据类型的方法"></a>28. JS 判断数据类型的方法</h3><p>JS 的基本数据类型有 7 中：number, string, boolean, undefined, null, symbol, bigint,<br>复杂数据类型有：object, array, function 和 Date<br>判断 JS 类型，有以下几种方法：1、typeof 2、object.property.toString.call 3、instance of。</p>
<ol>
<li>typeof</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;&quot;</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">43n</span>; <span class="comment">// bigint</span></span><br></pre></td></tr></table></figure>

<p>null 返回的是 “object”, 这个是基础类型里面的特例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>而复杂数据类型里，除了函数返回了”function”其他均返回“object”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// &quot;object&quot; 普通对象直接返回“object”</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">3</span>]; <span class="comment">// 数组返回&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 内置对象 &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>函数返回”function”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>所以我们可以发现，typeof 可以判断基本数据类型，但是难以判断除了函数以外的复杂数据类型。于是我们可以使用第二种方法，通常用来判断复杂数据类型，也可以用来判断基本数据类型。</p>
<ol start="2">
<li>Object.prototype.toString.call()<br>object.prototype.toString.call 方法 ,他返回”[object, 类型]”,注意返回的格式及大小写,前面是小写，后面是首字母大写。<br>基本数据类型都能返回相应的类型。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">999</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>()); <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42n</span>); <span class="comment">// &quot;[object BigInt]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &quot;[object Boolean]</span></span><br></pre></td></tr></table></figure>

<p>复杂数据类型也能返回相应的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>instanceof, 可以左边放你要判断的内容，右边放类型来进行 JS 类型判断，只能用来判断复杂数据类型,因为 instanceof 是用于检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">instanceof</span></span><br><span class="line">  <span class="title class_">Array</span>(</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  ) <span class="keyword">instanceof</span></span><br><span class="line">  <span class="title class_">Function</span>(</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ) <span class="keyword">instanceof</span></span><br><span class="line">  <span class="title class_">Object</span>(</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  ) <span class="keyword">instanceof</span></span><br><span class="line">  <span class="title class_">Date</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="29-React-的优化手段"><a href="#29-React-的优化手段" class="headerlink" title="29. React 的优化手段"></a>29. React 的优化手段</h3><ol>
<li>避免使用内联函数，避免在 render 方法中使用 bing 或者箭头函数</li>
<li>render 中的参数尽量使用同一对象 比如</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> style=&#123;&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 Immutable</li>
<li>React 懒加载 React.Suspense 和 React.lazy</li>
<li>列表数据使用单独组建进行渲染</li>
</ol>
<h3 id="30-webpack-优化手段"><a href="#30-webpack-优化手段" class="headerlink" title="30. webpack 优化手段"></a>30. webpack 优化手段</h3><ol>
<li>DllPlugin, 将不经常修改的第三方库和自己业务代码分开打包</li>
<li>合理使用 loader, 使用 include 和 exclude</li>
<li>cacheDirectory 缓存编译过的文件</li>
<li>tree Shaking 分析 import&#x2F;exports 依赖关系，对于没有使用的代码。可以自动删除。</li>
<li>多线程编译</li>
<li>code split</li>
<li>提取公共样式，ExtracTextPlugin</li>
<li>按需加载</li>
</ol>
<h3 id="31-动画-animation，transform-和-transition"><a href="#31-动画-animation，transform-和-transition" class="headerlink" title="31. 动画 animation，transform 和 transition"></a>31. 动画 animation，transform 和 transition</h3><h4 id="animation-包含-8-个属性"><a href="#animation-包含-8-个属性" class="headerlink" title="animation 包含 8 个属性"></a>animation 包含 8 个属性</h4><ul>
<li>name: @keyframes 的名称</li>
<li>duration: 动画持续时间</li>
<li>timing-function: 动画速度曲线：ease ease-in ease-out ease-in-out steps cubic-bezier(x1, y1, x2, y2)</li>
<li>delay: 延迟执行时间，可以为负数</li>
<li>iteration-count: 循环次数</li>
<li>direction: 是否反复执行动画，如果动画被设置为只播放一次，该属性将不起作用。</li>
<li>fill-mode: forwards 动画结束后的位置，backwards 动画开始的位置</li>
<li>play-state: paused 和 running，属性指定动画是否正在运行或已暂停</li>
</ul>
<h4 id="transform-属性应用于元素的-2D-或-3D-转换。这个属性允许你将元素旋转，缩放，移动，倾斜等"><a href="#transform-属性应用于元素的-2D-或-3D-转换。这个属性允许你将元素旋转，缩放，移动，倾斜等" class="headerlink" title="transform 属性应用于元素的 2D 或 3D 转换。这个属性允许你将元素旋转，缩放，移动，倾斜等"></a>transform 属性应用于元素的 2D 或 3D 转换。这个属性允许你将元素旋转，缩放，移动，倾斜等</h4><ul>
<li>translate</li>
<li>scale</li>
<li>rotate, transform-origin 设置圆心</li>
<li>skew</li>
<li>perspective</li>
</ul>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><ul>
<li>property</li>
<li>duration</li>
<li>timing-function</li>
<li>delay</li>
</ul>
<p>思考题：如何实现一个秒针转动？</p>
<h3 id="32-鼠标移到一个-div-上，如何计算鼠标距离改-div-左上角的位置？"><a href="#32-鼠标移到一个-div-上，如何计算鼠标距离改-div-左上角的位置？" class="headerlink" title="32. 鼠标移到一个 div 上，如何计算鼠标距离改 div 左上角的位置？"></a>32. 鼠标移到一个 div 上，如何计算鼠标距离改 div 左上角的位置？</h3><p>要理解<br>screenX，screenY 浏览器左上角</p>
<p>clientX, clientY 视窗左上角</p>
<p>offsetX, offsetY 事件源左上角</p>
<h3 id="33-AMD、CMD、CommonJs、ES6-的对比"><a href="#33-AMD、CMD、CommonJs、ES6-的对比" class="headerlink" title="33. AMD、CMD、CommonJs、ES6 的对比"></a>33. AMD、CMD、CommonJs、ES6 的对比</h3><p>AMD、CMD、CommonJs 是 ES5 中提供的模块化编程的方案，import&#x2F;export 是 ES6 中定义新增的</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个概念，RequireJS 是对这个概念的实现，就好比 JavaScript 语言是对 ECMAScript 规范的实现。AMD 是一个组织，RequireJS 是在这个组织下自定义的一套脚本语言</p>
<p>CMD—是 SeaJS 在推广过程中对模块定义的规范化产出，是一个同步模块定义，是 SeaJS 的一个标准，SeaJS 是 CMD 概念的一个实现，SeaJS 是淘宝团队提供的一个模块开发的 js 框架.</p>
<p>CommonJS 规范—是通过 module.exports 定义的，在前端浏览器里面并不支持 module.exports,通过 node.js 后端使用的。Nodejs 端是使用 CommonJS 规范的，前端浏览器一般使用 AMD、CMD、ES6 等定义模块化开发的</p>
<p>ES6 特性，模块化—export&#x2F;import 对模块进行导出导入的</p>
<h3 id="34-NodeList-和-HTMLCollection-的区别"><a href="#34-NodeList-和-HTMLCollection-的区别" class="headerlink" title="34. NodeList 和 HTMLCollection 的区别"></a>34. NodeList 和 HTMLCollection 的区别</h3><p>首先 NodeList 是 DOM 快照，节点数量和类型的快照，就是对节点增删，NodeList 感觉不到，但是对节点内部内容修改，是可以感觉到的，比如修改 innerHTML;<br>HtmlCollection 是 live 绑定的，节点的增删是敏感的；</p>
<p>直接对 NodeList， HtmlCollection 进行赋值，是失败的</p>
<p>元素是可读的，是对 dom 节点的引用</p>
<p>然后我就想将 NodeList,或者 HtmlCollection 排个序啥的，很常见的需求<br>既然直接修改不行，那我先存到数组</p>
<h3 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h3><p>堆的数据结构是完全二叉树。</p>
<h4 id="什么是完全二叉树呢？"><a href="#什么是完全二叉树呢？" class="headerlink" title="什么是完全二叉树呢？"></a>什么是完全二叉树呢？</h4><p>完全二叉树是对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p>
<h4 id="堆排序的数据结构"><a href="#堆排序的数据结构" class="headerlink" title="堆排序的数据结构"></a>堆排序的数据结构</h4><p>完全二叉树内如果每个节点的值都大于或等于子节点则为大顶堆，如果每个节点的值都小于或等于子节点则为小顶堆。<br>以上逻辑映射到数组可以定义为：<br>大顶堆 arr[i] &gt;&#x3D; arr[2<em>i + 1] &amp;&amp; arr[i] &gt;&#x3D; arr[2 * i + 2]<br>大顶堆 arr[i] &lt;&#x3D;&gt; arr[2</em>i + 1] &amp;&amp; arr[i] &lt;&gt;&#x3D; arr[2 * i + 2]</p>
<p>堆排序的时间复杂度最好情况，最坏情况，平均复杂度都是为 O(nlogn)，空间复杂度为 O(1)，为非稳定排序。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = arr.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="title function_ invoke__">heap_sort</span>(&amp;<span class="keyword">mut</span> arr, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result ===&gt; &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 堆排序总结</span></span><br><span class="line"><span class="comment">    第一步，反向构造大顶堆，</span></span><br><span class="line"><span class="comment">    第二部，首尾交换</span></span><br><span class="line"><span class="comment">    第三部：交换后正向修复大顶堆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">heap_sort</span>(arr: &amp;<span class="keyword">mut</span> [<span class="type">i64</span>], length: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// 构建大顶堆, 从下至上，从右向左，反向遍历所有非叶子节点，把最大值置于父节点位置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = length / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">adjust_heap</span>(arr, i, length);</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">j</span> = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">swap</span>(arr, <span class="number">0</span>, j);</span><br><span class="line">        <span class="title function_ invoke__">adjust_heap</span>(arr, <span class="number">0</span>, j);</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">adjust_heap</span>(arr: &amp;<span class="keyword">mut</span> [<span class="type">i64</span>], <span class="keyword">mut</span> i: <span class="type">usize</span>, length: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = arr[i];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">k</span> = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 正向遍历，使二叉树符合大顶堆结构,。</span></span><br><span class="line">    <span class="comment">// 正向遍历步骤：1. 判断两个子节点的大小，将k指向较大值</span></span><br><span class="line">    <span class="comment">// 2.k指向的值与temp节点比较</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; length &#123;</span><br><span class="line">        <span class="keyword">if</span> k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>] &#123;</span><br><span class="line">            k += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> arr[k] &gt; temp &#123;</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">swap</span>(arr: &amp;<span class="keyword">mut</span> [<span class="type">i64</span>], i: <span class="type">usize</span>, j: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">temp</span> = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>堆排序实现分为 3 个步骤<br>第一步：反向构造大顶堆，<br>第二部：收尾交换<br>第三部：交换后正向修复大顶堆</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.madaotech.top/2023/07/11/frontend/interview/" data-id="clm344esu0004l4p02mqp4lfg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/frontend/" rel="tag">frontend</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/07/11/solana/accounts/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">Newer</span>
      <div class="article-nav-title">
        
          account struct
        
      </div>
    </a>
  
  
    <a href="/2023/07/01/solana/PDA/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-caption">Older</span>
      <div class="article-nav-title">PDA</div>
    </a>
  
</nav>

  
</article>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023, Madaolabs<br />
      <!-- Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a> -->
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.loli.net/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

 
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
 
<script src="/fancybox/jquery.fancybox.pack.js"></script>
  
<script src="/js/script.js"></script>
 


  </div>
</body>
</html>